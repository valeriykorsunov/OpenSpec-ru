# Переход на OPSX

Это руководство поможет вам перейти с устаревшего рабочего процесса OpenSpec на OPSX. Переход спроектирован так, чтобы быть плавным: ваша существующая работа сохраняется, а новая система предлагает больше гибкости.

## Что меняется?

OPSX заменяет старый рабочий процесс с жестко фиксированными фазами на гибкий подход, основанный на действиях. Вот ключевые отличия:

| Аспект | Устаревший процесс | OPSX |
|--------|--------|------|
| **Команды** | `/openspec:proposal`, `/openspec:apply`, `/openspec:archive` | `/opsx:new`, `/opsx:continue`, `/opsx:apply` и другие |
| **Процесс** | Создание всех артефактов сразу | Создание постепенно или сразу — на ваш выбор |
| **Возврат назад** | Неудобные фазовые шлюзы | Естественный — обновление любого артефакта в любое время |
| **Кастомизация** | Фиксированная структура | Управляется схемой, полная настраиваемость |
| **Конфигурация** | `CLAUDE.md` с маркерами + `project.md` | Чистая конфигурация в `openspec/config.yaml` |

**Смена философии:** Работа не линейна. OPSX перестает притворяться, что это так.

---

## Перед началом

### Ваша существующая работа в безопасности

Процесс миграции разработан с учетом сохранения данных:

- **Активные изменения в `openspec/changes/`** — Полностью сохраняются. Вы можете продолжить работу над ними с помощью команд OPSX.
- **Архивные изменения** — Не затрагиваются. Ваша история остается нетронутой.
- **Основные спецификации в `openspec/specs/`** — Не затрагиваются. Это ваш "источник истины".
- **Ваш контент в CLAUDE.md, AGENTS.md и т.д.** — Сохраняется. Удаляются только блоки маркеров OpenSpec; все, что вы написали, остается.

### Что удаляется

Удаляются только файлы, управляемые OpenSpec, которые заменяются новыми:

| Что | Почему |
|------|-----|
| Директории/файлы устаревших слеш-команд | Заменяются новой системой навыков (skills) |
| `openspec/AGENTS.md` | Устаревший триггер рабочего процесса |
| Маркеры OpenSpec в `CLAUDE.md`, `AGENTS.md` и т.д. | Больше не нужны |

**Расположение устаревших команд по инструментам** (примеры — в вашем инструменте может отличаться):

- Claude Code: `.claude/commands/openspec/`
- Cursor: `.cursor/commands/openspec-*.md`
- Windsurf: `.windsurf/workflows/openspec-*.md`
- Cline: `.clinerules/workflows/openspec-*.md`
- Roo: `.roo/commands/openspec-*.md`
- GitHub Copilot: `.github/prompts/openspec-*.prompt.md`
- И другие (Augment, Continue, Amazon Q и т.д.)

Миграция определяет, какие инструменты у вас настроены, и очищает их устаревшие файлы.

Список на удаление может показаться длинным, но все это файлы, которые OpenSpec изначально создал сам. Ваш собственный контент никогда не удаляется.

### Что требует вашего внимания

Один файл требует ручного переноса:

**`openspec/project.md`** — Этот файл не удаляется автоматически, так как он может содержать написанный вами контекст проекта. Вам потребуется:

1. Просмотреть его содержимое.
2. Перенести полезный контекст в `openspec/config.yaml` (см. руководство ниже).
3. Удалить файл, когда будете готовы.

**Почему мы внесли это изменение:**

Старый `project.md` был пассивным — агенты могли прочитать его, а могли и нет, или забыть прочитанное. Мы обнаружили, что надежность была нестабильной.

Контекст в новом `config.yaml` **активно внедряется в каждый запрос планирования OpenSpec**. Это означает, что соглашения вашего проекта, технологический стек и правила всегда присутствуют при создании артефактов ИИ. Это обеспечивает более высокую надежность.

**Компромисс:**

Поскольку контекст внедряется в каждый запрос, старайтесь быть лаконичными. Сосредоточьтесь на том, что действительно важно:
- Технологический стек и ключевые соглашения.
- Неочевидные ограничения, о которых ИИ должен знать.
- Правила, которые раньше часто игнорировались.

Не беспокойтесь о том, чтобы сделать все идеально сразу. Мы все еще учимся тому, что работает лучше всего, и будем улучшать механизм внедрения контекста по мере экспериментов.

---

## Запуск миграции

Команды `openspec init` и `openspec update` обнаруживают устаревшие файлы и проводят вас через один и тот же процесс очистки. Используйте ту, которая подходит вашей ситуации:

### Использование `openspec init`

Запустите это, если хотите добавить новые инструменты или перенастроить текущие:

```bash
openspec init
```

Команда init обнаружит устаревшие файлы и предложит очистку:

```
Обновление до нового OpenSpec

OpenSpec теперь использует навыки агентов (agent skills) — развивающийся 
стандарт для ИИ-ассистентов. Это упрощает настройку, сохраняя 
функциональность.

Файлы для удаления
Пользовательский контент отсутствует:
  • .claude/commands/openspec/
  • openspec/AGENTS.md

Файлы для обновления
Маркеры OpenSpec будут удалены, ваш контент сохранен:
  • CLAUDE.md
  • AGENTS.md

Требует вашего внимания
  • openspec/project.md
    Мы не будем удалять этот файл. Он может содержать полезный контекст.

    В новом openspec/config.yaml есть раздел "context:" для планирования.
    Он включается в каждый запрос OpenSpec и работает надежнее, чем 
    старый подход с project.md.

    Просмотрите project.md, перенесите полезный контент в раздел context 
    файла config.yaml, затем удалите файл, когда будете готовы.

? Обновиться и очистить устаревшие файлы? (Y/n)
```

**Что произойдет при согласии:**

1. Директории устаревших слеш-команд будут удалены.
2. Маркеры OpenSpec будут удалены из `CLAUDE.md`, `AGENTS.md` и т.д. (ваш контент останется).
3. `openspec/AGENTS.md` будет удален.
4. Новые навыки будут установлены в `.claude/skills/`.
5. Будет создан `openspec/config.yaml` со схемой по умолчанию.

### Использование `openspec update`

Запустите это, если вы просто хотите обновить существующие инструменты до последней версии:

```bash
openspec update
```

Команда update также обнаруживает и очищает устаревшие артефакты, а затем обновляет ваши навыки до последней версии.

### Неинтерактивные среды / CI

Для автоматизированной миграции:

```bash
openspec init --force --tools claude
```

Флаг `--force` пропускает запросы и автоматически принимает очистку.

---

## Перенос project.md в config.yaml

Старый `openspec/project.md` был текстовым файлом в формате markdown для контекста проекта. Новый `openspec/config.yaml` структурирован и — что критично — **внедряется в каждый запрос планирования**, поэтому ваши соглашения всегда учитываются при работе ИИ.

### До (project.md)

```markdown
# Контекст проекта

Это monorepo на TypeScript с использованием React и Node.js.
Мы используем Jest для тестирования и следуем строгим правилам ESLint.
Наш API построен по принципам REST и документирован в docs/api.md.

## Соглашения

- Все публичные API должны сохранять обратную совместимость
- Новые функции должны включать тесты
- Используйте формат Given/When/Then для спецификаций
```

### После (config.yaml)

```yaml
schema: spec-driven

context: |
  Технологический стек: TypeScript, React, Node.js
  Тестирование: Jest с React Testing Library
  API: RESTful, документирован в docs/api.md
  Мы сохраняем обратную совместимость для всех публичных API

rules:
  proposal:
    - Включать план отката для рискованных изменений
  specs:
    - Использовать формат Given/When/Then для сценариев
    - Ссылаться на существующие паттерны перед созданием новых
  design:
    - Включать диаграммы последовательности для сложных процессов
```

### Ключевые отличия

| project.md | config.yaml |
|------------|-------------|
| Произвольный markdown | Структурированный YAML |
| Единый блок текста | Раздельный контекст и правила для каждого артефакта |
| Неясно, когда используется | Контекст появляется во ВСЕХ артефактах; правила — только в соответствующих |
| Нет выбора схемы | Явное поле `schema:` задает процесс по умолчанию |

### Что оставить, а что убрать

При миграции будьте избирательны. Спросите себя: "Нужно ли это ИИ для *каждого* запроса планирования?"

**Хорошие кандидаты для `context:`**
- Технологический стек (языки, фреймворки, базы данных).
- Ключевые архитектурные паттерны (monorepo, microservices и т.д.).
- Неочевидные ограничения ("мы не можем использовать библиотеку X, потому что...").
- Критически важные соглашения, которые часто игнорируются.

**Перенесите в `rules:`**
- Форматирование конкретных артефактов ("использовать Given/When/Then в спецификациях").
- Критерии проверки ("предложения должны включать план отката").
- Это будет появляться только для соответствующего артефакта, облегчая остальные запросы.

**Уберите совсем**
- Общие лучшие практики, которые ИИ и так знает.
- Многословные объяснения, которые можно сократить.
- Исторический контекст, не влияющий на текущую работу.

### Шаги миграции

1. **Создайте config.yaml** (если он еще не создан командой init):
   ```yaml
   schema: spec-driven
   ```

2. **Добавьте ваш контекст** (будьте кратки — это идет в каждый запрос):
   ```yaml
   context: |
     Здесь описание вашего проекта.
     Сосредоточьтесь на том, что ИИ действительно нужно знать.
   ```

3. **Добавьте правила для артефактов** (опционально):
   ```yaml
   rules:
     proposal:
       - Ваши рекомендации для предложений
     specs:
       - Ваши правила написания спецификаций
   ```

4. **Удалите project.md**, когда перенесете все полезное.

**Не усложняйте.** Начните с самого важного и итерируйте. Если заметите, что ИИ упускает что-то важное — добавьте это. Если контекст кажется раздутым — сократите его. Это живой документ.

### Нужна помощь? Используйте этот промпт

Если вы не уверены, как сократить ваш project.md, спросите своего ИИ-ассистента:

```
Я перехожу со старого формата project.md OpenSpec на новый формат config.yaml.

Вот мой текущий project.md:
[вставьте содержимое вашего project.md]

Пожалуйста, помоги мне создать config.yaml с:
1. Лаконичным разделом `context:` (он внедряется в каждый запрос планирования, поэтому пиши кратко — сосредоточься на техстеке, ключевых ограничениях и соглашениях, которые часто игнорируются).
2. Разделом `rules:` для конкретных артефактов, если контент специфичен для них (например, "использовать Given/When/Then" относится к правилам спецификаций, а не к глобальному контексту).

Убери все общее, что ИИ и так знает. Будь беспощаден в сокращении.
```

ИИ поможет вам определить, что важно, а что можно убрать.

---

## Новые команды

После миграции у вас будет 9 команд OPSX вместо 3:

| Команда | Назначение |
|---------|---------|
| `/opsx:explore` | Продумывание идей без жесткой структуры |
| `/opsx:new` | Начало нового изменения |
| `/opsx:continue` | Создание следующего артефакта (по одному) |
| `/opsx:ff` | Fast-forward — создание всех артефактов планирования сразу |
| `/opsx:apply` | Реализация задач из tasks.md |
| `/opsx:verify` | Проверка соответствия реализации спецификациям |
| `/opsx:sync` | Предпросмотр объединения спецификаций (опционально) |
| `/opsx:archive` | Финализация и архивация изменения |
| `/opsx:bulk-archive` | Архивирование нескольких изменений сразу |

### Соответствие команд старым версиям

| Устаревшая команда | Эквивалент OPSX |
|--------|-----------------|
| `/openspec:proposal` | `/opsx:new`, затем `/opsx:ff` |
| `/openspec:apply` | `/opsx:apply` |
| `/openspec:archive` | `/opsx:archive` |

### Новые возможности

**Гранулярное создание артефактов:**
```
/opsx:continue
```
Создает по одному артефакту за раз на основе зависимостей. Используйте, когда хотите проверять каждый шаг.

**Режим исследования:**
```
/opsx:explore
```
Обсуждайте идеи с партнером перед тем, как зафиксировать изменение.

---

## Понимание новой архитектуры

### От фиксированных фаз к гибкости

Устаревший рабочий процесс навязывал линейную прогрессию:

```
┌──────────────┐      ┌──────────────┐      ┌──────────────┐
│     ФАЗА     │ ───► │     ФАЗА     │ ───► │     ФАЗА     │
│ ПЛАНИРОВАНИЯ │      │  РЕАЛИЗАЦИИ  │      │ АРХИВАЦИИ    │
└──────────────┘      └──────────────┘      └──────────────┘

Если вы в процессе реализации поняли, что дизайн неверен?
Увы. Фазовые шлюзы не позволяют легко вернуться назад.
```

OPSX использует действия, а не фазы:

```
         ┌───────────────────────────────────────────────┐
         │           ДЕЙСТВИЯ (не фазы)                  │
         │                                               │
         │     new ◄──► continue ◄──► apply ◄──► archive │
         │      │          │           │             │   │
         │      └──────────┴───────────┴─────────────┘   │
         │                любой порядок                  │
         └───────────────────────────────────────────────┘
```

### Граф зависимостей

Артефакты формируют направленный граф. Зависимости — это возможности, а не препятствия:

```
                        proposal
                     (корневой узел)
                            │
              ┌─────────────┴─────────────┐
              │                           │
              ▼                           ▼
           specs                       design
        (требует:                   (требует:
         proposal)                   proposal)
              │                           │
              └─────────────┬─────────────┘
                            │
                            ▼
                         tasks
                     (требует:
                     specs, design)
```

При запуске `/opsx:continue` система проверяет, что готово, и предлагает следующий артефакт. Вы также можете создавать несколько готовых артефактов в любом порядке.

### Навыки против Команд

Устаревшая система использовала файлы команд, специфичные для инструментов:

```
.claude/commands/openspec/
├── proposal.md
├── apply.md
└── archive.md
```

OPSX использует развивающийся стандарт **навыков (skills)**:

```
.claude/skills/
├── openspec-explore/SKILL.md
├── openspec-new-change/SKILL.md
├── openspec-continue-change/SKILL.md
├── openspec-apply-change/SKILL.md
└── ...
```

Навыки распознаются множеством инструментов для ИИ-программирования и предоставляют более богатые метаданные.

---

## Продолжение существующих изменений

Ваши текущие изменения плавно интегрируются с командами OPSX.

**У вас есть активное изменение из устаревшего рабочего процесса?**

```
/opsx:apply add-my-feature
```

OPSX прочитает существующие артефакты и продолжит с того места, где вы остановились.

**Хотите добавить больше артефактов к существующему изменению?**

```
/opsx:continue add-my-feature
```

Покажет, что готово к созданию на основе того, что уже существует.

**Нужно увидеть статус?**

```bash
openspec status --change add-my-feature
```

---

## Новая система конфигурации

### Структура config.yaml

```yaml
# Обязательно: Схема по умолчанию для новых изменений
schema: spec-driven

# Опционально: Контекст проекта (макс. 50 КБ)
# Внедряется во ВСЕ инструкции артефактов
context: |
  Описание вашего проекта, техстек,
  соглашения и ограничения.

# Опционально: Правила для отдельных артефактов
# Внедряются только в соответствующие артефакты
rules:
  proposal:
    - Включать план отката
  specs:
    - Использовать формат Given/When/Then
  design:
    - Документировать стратегии отката
  tasks:
    - Разбивать на задачи максимум по 2 часа
```

### Разрешение схем

При определении используемой схемы OPSX проверяет их в следующем порядке:

1. **Флаг CLI**: `--schema <name>` (высший приоритет)
2. **Метаданные изменения**: `.openspec.yaml` в директории изменения
3. **Конфигурация проекта**: `openspec/config.yaml`
4. **По умолчанию**: `spec-driven`

### Доступные схемы

| Схема | Артефакты | Лучше всего для |
|--------|-----------|----------|
| `spec-driven` | proposal → specs → design → tasks | Большинства проектов |

Список всех доступных схем:

```bash
openspec schemas
```

### Кастомные схемы

Создайте собственный рабочий процесс:

```bash
openspec schema init my-workflow
```

Или форкните существующую:

```bash
openspec schema fork spec-driven my-workflow
```

Подробности см. в разделе [Кастомизация](customization.md).

---

## Устранение неполадок

### "Legacy files detected in non-interactive mode"

Вы запускаете миграцию в CI или неинтерактивной среде. Используйте:

```bash
openspec init --force
```

### Команды не появляются после миграции

Перезапустите вашу IDE. Навыки обнаруживаются при запуске.

### "Unknown artifact ID in rules"

Убедитесь, что ключи в `rules:` соответствуют ID артефактов вашей схемы:

- **spec-driven**: `proposal`, `specs`, `design`, `tasks`

Запустите это, чтобы увидеть валидные ID артефактов:

```bash
openspec schemas --json
```

### Конфигурация не применяется

1. Убедитесь, что файл называется `openspec/config.yaml` (не `.yml`).
2. Проверьте синтаксис YAML.
3. Изменения конфигурации вступают в силу немедленно — перезагрузка не требуется.

### project.md не мигрировал

Система намеренно сохраняет `project.md`, так как он может содержать ваш контент. Просмотрите его вручную, перенесите полезные части в `config.yaml`, затем удалите.

### Хотите увидеть, что будет удалено?

Запустите init и отклоните запрос на очистку — вы увидите сводку обнаруженных файлов без внесения изменений.

---

## Краткий справочник

### Файлы после миграции

```
project/
├── openspec/
│   ├── specs/                    # Без изменений
│   ├── changes/                  # Без изменений
│   │   └── archive/              # Без изменений
│   └── config.yaml               # НОВОЕ: Конфигурация проекта
├── .claude/
│   └── skills/                   # НОВОЕ: Навыки OPSX
│       ├── openspec-explore/
│       ├── openspec-new-change/
│       └── ...
├── CLAUDE.md                     # Маркеры OpenSpec удалены, контент сохранен
└── AGENTS.md                     # Маркеры OpenSpec удалены, контент сохранен
```

### Что исчезло

- `.claude/commands/openspec/` — заменено на `.claude/skills/`
- `openspec/AGENTS.md` — устарело
- `openspec/project.md` — перенесите в `config.yaml`, затем удалите
- Блоки маркеров OpenSpec в `CLAUDE.md`, `AGENTS.md` и т.д.

### Шпаргалка по командам

```
/opsx:new          Начать изменение
/opsx:continue     Создать следующий артефакт
/opsx:ff           Создать все артефакты планирования
/opsx:apply        Реализовать задачи
/opsx:archive      Завершить и архивировать
```

---

## Помощь

- **Discord**: [discord.gg/YctCnvvshC](https://discord.gg/YctCnvvshC)
- **GitHub Issues**: [github.com/Fission-AI/OpenSpec/issues](https://github.com/Fission-AI/OpenSpec/issues)
- **Документация**: [docs/opsx.md](opsx.md) — полный справочник OPSX
